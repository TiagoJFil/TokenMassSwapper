/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Dexhunter API
 * This is the API for the Dexhunter project
 *
 * OpenAPI spec version: 1.0
 * Contact: support@dexhunter.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import fetchFetchApi from './fetchFetchApi';
import { DexHunterApiError } from './exceptions';

const BASE_PATH = "https://api-us.dexhunterv3.app".replace(/\/+$/, "");

const PartnerHeader = "X-Partner-Id"
/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration?: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = fetchFetchApi) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface DcascCancelDCARequest
 */
export interface DcascCancelDCARequest {
    /**
     * 
     * @type {string}
     * @memberof DcascCancelDCARequest
     */
    dcaId?: string;
    /**
     * 
     * @type {string}
     * @memberof DcascCancelDCARequest
     */
    userAddress?: string;
}

/**
 * 
 * @export
 * @interface DcascCreateDCARequest
 */
export interface DcascCreateDCARequest {
    /**
     * 
     * @type {number}
     * @memberof DcascCreateDCARequest
     */
    amountIn?: number;
    /**
     * 
     * @type {number}
     * @memberof DcascCreateDCARequest
     */
    cycles?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DcascCreateDCARequest
     */
    dexAllowlist?: Array<string>;
    /**
     * 
     * @type {DcascDcaInterval}
     * @memberof DcascCreateDCARequest
     */
    interval?: DcascDcaInterval;
    /**
     * 
     * @type {number}
     * @memberof DcascCreateDCARequest
     */
    intervalLength?: number;
    /**
     * 
     * @type {string}
     * @memberof DcascCreateDCARequest
     */
    tokenIn?: string;
    /**
     * 
     * @type {string}
     * @memberof DcascCreateDCARequest
     */
    tokenOut?: string;
    /**
     * 
     * @type {string}
     * @memberof DcascCreateDCARequest
     */
    userAddress?: string;
}

/**
 * 
 * @export
 * @interface DcascCreateDCAResponse
 */
export interface DcascCreateDCAResponse {
    /**
     * 
     * @type {number}
     * @memberof DcascCreateDCAResponse
     */
    amountAdaIn?: number;
    /**
     * 
     * @type {number}
     * @memberof DcascCreateDCAResponse
     */
    amountTokenIn?: number;
    /**
     * 
     * @type {number}
     * @memberof DcascCreateDCAResponse
     */
    batchersDeposit?: number;
    /**
     * 
     * @type {string}
     * @memberof DcascCreateDCAResponse
     */
    cbor?: string;
    /**
     * 
     * @type {string}
     * @memberof DcascCreateDCAResponse
     */
    dcaId?: string;
    /**
     * 
     * @type {number}
     * @memberof DcascCreateDCAResponse
     */
    dhFee?: number;
    /**
     * 
     * @type {number}
     * @memberof DcascCreateDCAResponse
     */
    txFeesDeposit?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum DcascDCASTATUS {
    Active = <any> 'active',
    Error = <any> 'error',
    Done = <any> 'done'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum DcascDcaInterval {
    Minutely = <any> 'minutely',
    Hourly = <any> 'hourly',
    Daily = <any> 'daily',
    Weekly = <any> 'weekly',
    Monthly = <any> 'monthly',
    Quarterly = <any> 'quarterly'
}

/**
 * 
 * @export
 * @interface DcascDcaResponse
 */
export interface DcascDcaResponse {
    /**
     * 
     * @type {number}
     * @memberof DcascDcaResponse
     */
    amountDcad?: number;
    /**
     * 
     * @type {string}
     * @memberof DcascDcaResponse
     */
    creationTx?: string;
    /**
     * 
     * @type {number}
     * @memberof DcascDcaResponse
     */
    currentSlot?: number;
    /**
     * 
     * @type {number}
     * @memberof DcascDcaResponse
     */
    dcaAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof DcascDcaResponse
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof DcascDcaResponse
     */
    interval?: number;
    /**
     * 
     * @type {string}
     * @memberof DcascDcaResponse
     */
    lastExecution?: string;
    /**
     * 
     * @type {string}
     * @memberof DcascDcaResponse
     */
    nextExecution?: string;
    /**
     * 
     * @type {number}
     * @memberof DcascDcaResponse
     */
    remainingCycles?: number;
    /**
     * 
     * @type {DcascDCASTATUS}
     * @memberof DcascDcaResponse
     */
    status?: DcascDCASTATUS;
    /**
     * 
     * @type {string}
     * @memberof DcascDcaResponse
     */
    tokenIn?: string;
    /**
     * 
     * @type {string}
     * @memberof DcascDcaResponse
     */
    tokenOut?: string;
    /**
     * 
     * @type {number}
     * @memberof DcascDcaResponse
     */
    totalDca?: number;
}

/**
 * 
 * @export
 * @interface DtoCancelRequest
 */
export interface DtoCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoCancelRequest
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoCancelRequest
     */
    orderId?: string;
}

/**
 * 
 * @export
 * @interface DtoCancelResponse
 */
export interface DtoCancelResponse {
    /**
     * 
     * @type {number}
     * @memberof DtoCancelResponse
     */
    additionalCancellationFee?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoCancelResponse
     */
    cbor?: string;
}

/**
 * 
 * @export
 * @interface DtoEstimateRequest
 */
export interface DtoEstimateRequest {
    /**
     * 
     * @type {number}
     * @memberof DtoEstimateRequest
     */
    amountIn?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoEstimateRequest
     */
    blacklistedDexes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoEstimateRequest
     */
    singlePreferredDex?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoEstimateRequest
     */
    slippage?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoEstimateRequest
     */
    tokenIn?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoEstimateRequest
     */
    tokenOut?: string;
}

/**
 * 
 * @export
 * @interface DtoEstimateResponse
 */
export interface DtoEstimateResponse {
    /**
     * 
     * @type {number}
     * @memberof DtoEstimateResponse
     */
    averagePrice?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoEstimateResponse
     */
    batcherFee?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoEstimateResponse
     */
    communications?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DtoEstimateResponse
     */
    deposits?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoEstimateResponse
     */
    dexhunterFee?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoEstimateResponse
     */
    netPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoEstimateResponse
     */
    netPriceReverse?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoEstimateResponse
     */
    partnerCode?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoEstimateResponse
     */
    partnerFee?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof DtoEstimateResponse
     */
    possibleRoutes?: { [key: string]: number; };
    /**
     * 
     * @type {Array<ModelsSplit>}
     * @memberof DtoEstimateResponse
     */
    splits?: Array<ModelsSplit>;
    /**
     * 
     * @type {number}
     * @memberof DtoEstimateResponse
     */
    totalFee?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoEstimateResponse
     */
    totalOutput?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoEstimateResponse
     */
    totalOutputWithoutSlippage?: number;
}

/**
 * 
 * @export
 * @interface DtoLimitOrderEstimate
 */
export interface DtoLimitOrderEstimate {
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderEstimate
     */
    batcherFee?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoLimitOrderEstimate
     */
    blacklistedDexes?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderEstimate
     */
    deposits?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderEstimate
     */
    dexhunterFee?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderEstimate
     */
    netPrice?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoLimitOrderEstimate
     */
    partner?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderEstimate
     */
    partnerFee?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoLimitOrderEstimate
     */
    possibleRoutes?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ModelsSplit>}
     * @memberof DtoLimitOrderEstimate
     */
    splits?: Array<ModelsSplit>;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderEstimate
     */
    totalFee?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderEstimate
     */
    totalInput?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderEstimate
     */
    totalOutput?: number;
}

/**
 * 
 * @export
 * @interface DtoLimitOrderRequest
 */
export interface DtoLimitOrderRequest {
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderRequest
     */
    amountIn?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoLimitOrderRequest
     */
    blacklistedDexes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoLimitOrderRequest
     */
    buyerAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoLimitOrderRequest
     */
    dex?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderRequest
     */
    multiples?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoLimitOrderRequest
     */
    tokenIn?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoLimitOrderRequest
     */
    tokenOut?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderRequest
     */
    wantedPrice?: number;
}

/**
 * 
 * @export
 * @interface DtoLimitOrderResponse
 */
export interface DtoLimitOrderResponse {
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderResponse
     */
    batcherFee?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoLimitOrderResponse
     */
    cbor?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderResponse
     */
    deposits?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderResponse
     */
    dexhunterFee?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoLimitOrderResponse
     */
    partner?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderResponse
     */
    partnerFee?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DtoLimitOrderResponse
     */
    possibleRoutes?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ModelsSplit>}
     * @memberof DtoLimitOrderResponse
     */
    splits?: Array<ModelsSplit>;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderResponse
     */
    totalFee?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderResponse
     */
    totalInput?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoLimitOrderResponse
     */
    totalOutput?: number;
}

/**
 * 
 * @export
 * @interface DtoOrderFilter
 */
export interface DtoOrderFilter {
    /**
     * 
     * @type {DtoOrderFilterType}
     * @memberof DtoOrderFilter
     */
    filterType?: DtoOrderFilterType;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoOrderFilter
     */
    values?: Array<string>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum DtoOrderFilterType {
    TOKENID = <any> 'TOKENID',
    STATUS = <any> 'STATUS',
    TXTYPE = <any> 'TXTYPE',
    TIMESTART = <any> 'TIMESTART',
    TIMEEND = <any> 'TIMEEND',
    DEXNAME = <any> 'DEXNAME',
    SEARCH = <any> 'SEARCH',
    ADDRESS = <any> 'ADDRESS',
    MINAMOUNT = <any> 'MINAMOUNT',
    MAXAMOUNT = <any> 'MAXAMOUNT',
    TXHASH = <any> 'TXHASH',
    OWNED = <any> 'OWNED'
}

/**
 * 
 * @export
 * @interface DtoOrderRequest
 */
export interface DtoOrderRequest {
    /**
     * 
     * @type {Array<DtoOrderFilter>}
     * @memberof DtoOrderRequest
     */
    filters?: Array<DtoOrderFilter>;
    /**
     * 
     * @type {DtoOrderSorts}
     * @memberof DtoOrderRequest
     */
    orderSorts?: DtoOrderSorts;
    /**
     * 
     * @type {number}
     * @memberof DtoOrderRequest
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrderRequest
     */
    perPage?: number;
    /**
     * 
     * @type {DtoSortDirection}
     * @memberof DtoOrderRequest
     */
    sortDirection?: DtoSortDirection;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum DtoOrderSorts {
    AMOUNTIN = <any> 'AMOUNTIN',
    DATE = <any> 'DATE'
}

/**
 * 
 * @export
 * @interface DtoReverseEstimateResponse
 */
export interface DtoReverseEstimateResponse {
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    averagePrice?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    batcherFee?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoReverseEstimateResponse
     */
    communications?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    deposits?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    dexhunterFee?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    netPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    netPriceReverse?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    partnerFee?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof DtoReverseEstimateResponse
     */
    possibleRoutes?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    priceAb?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    priceBa?: number;
    /**
     * 
     * @type {Array<ModelsSplit>}
     * @memberof DtoReverseEstimateResponse
     */
    splits?: Array<ModelsSplit>;
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    totalFee?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    totalInput?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    totalInputWithoutSlippage?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimateResponse
     */
    totalOutput?: number;
}

/**
 * 
 * @export
 * @interface DtoReverseEstimationRequest
 */
export interface DtoReverseEstimationRequest {
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimationRequest
     */
    amountOut?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoReverseEstimationRequest
     */
    blacklistedDexes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoReverseEstimationRequest
     */
    buyerAddress?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DtoReverseEstimationRequest
     */
    isOptimized?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DtoReverseEstimationRequest
     */
    slippage: number;
    /**
     * 
     * @type {string}
     * @memberof DtoReverseEstimationRequest
     */
    tokenIn: string;
    /**
     * 
     * @type {string}
     * @memberof DtoReverseEstimationRequest
     */
    tokenOut: string;
}

/**
 * 
 * @export
 * @interface DtoSignatureResponse
 */
export interface DtoSignatureResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoSignatureResponse
     */
    cbor?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoSignatureResponse
     */
    stratId?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum DtoSortDirection {
    ASC = <any> 'ASC',
    DESC = <any> 'DESC'
}

/**
 * 
 * @export
 * @interface DtoSubmissionModel
 */
export interface DtoSubmissionModel {
    /**
     * 
     * @type {string}
     * @memberof DtoSubmissionModel
     */
    signatures?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoSubmissionModel
     */
    txCbor?: string;
}

/**
 * 
 * @export
 * @interface DtoSwapObject
 */
export interface DtoSwapObject {
    /**
     * 
     * @type {number}
     * @memberof DtoSwapObject
     */
    amount_in: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoSwapObject
     */
    blacklisted_dexes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DtoSwapObject
     */
    buyer_address: string;

    referrer?: string;

    tx_optimization : boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoSwapObject
     */
    inputs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DtoSwapObject
     */
    slippage: number;
    /**
     * 
     * @type {string}
     * @memberof DtoSwapObject
     */
    token_in: string;
    /**
     * 
     * @type {string}
     * @memberof DtoSwapObject
     */
    token_out: string;
}

/**
 * 
 * @export
 * @interface DtoSwapResponse
 */






export interface DtoSwapResponse {
    /**
     * 
     * @type {number}
     * @memberof DtoSwapResponse
     */
    averagePrice?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoSwapResponse
     */
    batcherFee?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoSwapResponse
     */
    cbor?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoSwapResponse
     */
    communications?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DtoSwapResponse
     */
    deposits?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoSwapResponse
     */
    dexhunterFee?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoSwapResponse
     */
    netPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoSwapResponse
     */
    netPriceReverse?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoSwapResponse
     */
    partnerCode?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoSwapResponse
     */
    partnerFee?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof DtoSwapResponse
     */
    possibleRoutes?: { [key: string]: number; };
    /**
     * 
     * @type {Array<ModelsSplit>}
     * @memberof DtoSwapResponse
     */
    splits?: Array<ModelsSplit>;
    /**
     * 
     * @type {number}
     * @memberof DtoSwapResponse
     */
    totalFee?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoSwapResponse
     */
    totalInput?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoSwapResponse
     */
    totalInputWithoutSlippage?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoSwapResponse
     */
    totalOutput?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoSwapResponse
     */
    totalOutputWithoutSlippage?: number;
}

/**
 * 
 * @export
 * @interface DtoWallet
 */
export interface DtoWallet {
    /**
     * 
     * @type {Array<string>}
     * @memberof DtoWallet
     */
    addresses?: Array<string>;
}

/**
 * 
 * @export
 * @interface DtoWalletInfoResponse
 */
export interface DtoWalletInfoResponse {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof DtoWalletInfoResponse
     */
    cardano?: { [key: string]: number; };
    /**
     * 
     * @type {Array<ModelsUserToken>}
     * @memberof DtoWalletInfoResponse
     */
    tokens?: Array<ModelsUserToken>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum MarkersMarkType {
    LIMIT = <any> 'LIMIT',
    STOPLOSS = <any> 'STOP_LOSS',
    DCA = <any> 'DCA',
    SWAP = <any> 'SWAP'
}

/**
 * 
 * @export
 * @interface MarkersMarkerBody
 */
export interface MarkersMarkerBody {
    /**
     * 
     * @type {string}
     * @memberof MarkersMarkerBody
     */
    cbor?: string;
    /**
     * 
     * @type {MarkersMarkType}
     * @memberof MarkersMarkerBody
     */
    orderType?: MarkersMarkType;
    /**
     * 
     * @type {string}
     * @memberof MarkersMarkerBody
     */
    txHash?: string;
}

/**
 * 
 * @export
 * @interface ModelsApiOrder
 */
export interface ModelsApiOrder {
    /**
     * 
     * @type {string}
     * @memberof ModelsApiOrder
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsApiOrder
     */
    actualOutAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsApiOrder
     */
    amountIn?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsApiOrder
     */
    batcherFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsApiOrder
     */
    deposit?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsApiOrder
     */
    dex?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsApiOrder
     */
    expectedOutAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsApiOrder
     */
    isDexhunter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsApiOrder
     */
    isOor?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsApiOrder
     */
    isStopLoss?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelsApiOrder
     */
    lastUpdate?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsApiOrder
     */
    outputIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsApiOrder
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsApiOrder
     */
    submissionTime?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsApiOrder
     */
    tokenIdIn?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsApiOrder
     */
    tokenIdOut?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsApiOrder
     */
    txHash?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsApiOrder
     */
    updateTxHash?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsApiOrder
     */
    userAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsApiOrder
     */
    userStake?: string;
}

/**
 * 
 * @export
 * @interface ModelsChartRequest
 */
export interface ModelsChartRequest {
    /**
     * 
     * @type {number}
     * @memberof ModelsChartRequest
     */
    from?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsChartRequest
     */
    isLast?: boolean;
    /**
     * 
     * @type {ModelsPeriod}
     * @memberof ModelsChartRequest
     */
    period?: ModelsPeriod;
    /**
     * 
     * @type {number}
     * @memberof ModelsChartRequest
     */
    to?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsChartRequest
     */
    tokenIn?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsChartRequest
     */
    tokenOut?: string;
}

/**
 * 
 * @export
 * @interface ModelsOptimCandleStick
 */
export interface ModelsOptimCandleStick {
    /**
     * 
     * @type {number}
     * @memberof ModelsOptimCandleStick
     */
    close?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOptimCandleStick
     */
    high?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOptimCandleStick
     */
    low?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOptimCandleStick
     */
    open?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOptimCandleStick
     */
    timestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsOptimCandleStick
     */
    volume?: number;
}

/**
 * 
 * @export
 * @interface ModelsOptimChartResponse
 */
export interface ModelsOptimChartResponse {
    /**
     * 
     * @type {Array<ModelsOptimCandleStick>}
     * @memberof ModelsOptimChartResponse
     */
    data?: Array<ModelsOptimCandleStick>;
    /**
     * 
     * @type {ModelsPeriod}
     * @memberof ModelsOptimChartResponse
     */
    period?: ModelsPeriod;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ModelsPeriod {
    _1min = <any> '1min',
    _5min = <any> '5min',
    _15min = <any> '15min',
    _30min = <any> '30min',
    _1hour = <any> '1hour',
    _4hour = <any> '4hour',
    _1day = <any> '1day'
}

/**
 * 
 * @export
 * @interface ModelsSplit
 */
export interface ModelsSplit {
    /**
     * 
     * @type {number}
     * @memberof ModelsSplit
     */
    amountIn?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSplit
     */
    batcherFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSplit
     */
    deposits?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSplit
     */
    dex?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSplit
     */
    expectedOutput?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSplit
     */
    expectedOutputWithoutSlippage?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSplit
     */
    fee?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSplit
     */
    finalPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSplit
     */
    initialPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSplit
     */
    poolFee?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsSplit
     */
    poolId?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsSplit
     */
    priceDistortion?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsSplit
     */
    priceImpact?: number;
}

/**
 * 
 * @export
 * @interface ModelsUserToken
 */
export interface ModelsUserToken {
    /**
     * 
     * @type {number}
     * @memberof ModelsUserToken
     */
    adaValue?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsUserToken
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsUserToken
     */
    ticker?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsUserToken
     */
    tokenAscii?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsUserToken
     */
    tokenId?: string;
}


/**
 * ChartsApi - fetch parameter creator
 * @export
 */
export const ChartsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get charts
         * @summary Get charts
         * @param {ModelsChartRequest} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartsPost(body: ModelsChartRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling chartsPost.');
            }
            const localVarPath = `/charts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
if (configuration && configuration.partnerToken) {
    localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
}

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ModelsChartRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChartsApi - functional programming interface
 * @export
 */
export const ChartsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get charts
         * @summary Get charts
         * @param {ModelsChartRequest} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartsPost(body: ModelsChartRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelsOptimChartResponse> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).chartsPost(body, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChartsApi - factory interface
 * @export
 */
export const ChartsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get charts
         * @summary Get charts
         * @param {ModelsChartRequest} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartsPost(body: ModelsChartRequest, options?: any) {
            return ChartsApiFp(configuration).chartsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * ChartsApi - object-oriented interface
 * @export
 * @class ChartsApi
 * @extends {BaseAPI}
 */
export class ChartsApi extends BaseAPI {
    /**
     * Get charts
     * @summary Get charts
     * @param {ModelsChartRequest} body body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public chartsPost(body: ModelsChartRequest, options?: any) {
        return ChartsApiFp(this.configuration).chartsPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * DCAApi - fetch parameter creator
 * @export
 */
export const DCAApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Dcas
         * @summary Get Dcas
         * @param {string} address Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcaAddressGet(address: string, options: any = {}): FetchArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling dcaAddressGet.');
            }
            const localVarPath = `/dca/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Dca
         * @summary Cancel Dca
         * @param {DcascCancelDCARequest} request Cancel DCA Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcaCancelPost(request: DcascCancelDCARequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling dcaCancelPost.');
            }
            const localVarPath = `/dca/cancel`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
if (configuration && configuration.partnerToken) {
    localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
}

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DcascCancelDCARequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Dca
         * @summary Create Dca
         * @param {DcascCreateDCARequest} request Create DCA Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcaCreatePost(request: DcascCreateDCARequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling dcaCreatePost.');
            }
            const localVarPath = `/dca/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
if (configuration && configuration.partnerToken) {
    localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
}

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DcascCreateDCARequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimate Dca
         * @summary Estimate Dca
         * @param {DcascCreateDCARequest} request Create DCA Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcaEstimatePost(request: DcascCreateDCARequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling dcaEstimatePost.');
            }
            const localVarPath = `/dca/estimate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
if (configuration && configuration.partnerToken) {
    localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
}

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DcascCreateDCARequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DCAApi - functional programming interface
 * @export
 */
export const DCAApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Dcas
         * @summary Get Dcas
         * @param {string} address Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcaAddressGet(address: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DcascDcaResponse>> {
            const localVarFetchArgs = DCAApiFetchParamCreator(configuration).dcaAddressGet(address, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Cancel Dca
         * @summary Cancel Dca
         * @param {DcascCancelDCARequest} request Cancel DCA Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcaCancelPost(request: DcascCancelDCARequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: string; }> {
            const localVarFetchArgs = DCAApiFetchParamCreator(configuration).dcaCancelPost(request, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create Dca
         * @summary Create Dca
         * @param {DcascCreateDCARequest} request Create DCA Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcaCreatePost(request: DcascCreateDCARequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DcascCreateDCAResponse> {
            const localVarFetchArgs = DCAApiFetchParamCreator(configuration).dcaCreatePost(request, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Estimate Dca
         * @summary Estimate Dca
         * @param {DcascCreateDCARequest} request Create DCA Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcaEstimatePost(request: DcascCreateDCARequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DcascCreateDCAResponse> {
            const localVarFetchArgs = DCAApiFetchParamCreator(configuration).dcaEstimatePost(request, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DCAApi - factory interface
 * @export
 */
export const DCAApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get Dcas
         * @summary Get Dcas
         * @param {string} address Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcaAddressGet(address: string, options?: any) {
            return DCAApiFp(configuration).dcaAddressGet(address, options)(fetch, basePath);
        },
        /**
         * Cancel Dca
         * @summary Cancel Dca
         * @param {DcascCancelDCARequest} request Cancel DCA Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcaCancelPost(request: DcascCancelDCARequest, options?: any) {
            return DCAApiFp(configuration).dcaCancelPost(request, options)(fetch, basePath);
        },
        /**
         * Create Dca
         * @summary Create Dca
         * @param {DcascCreateDCARequest} request Create DCA Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcaCreatePost(request: DcascCreateDCARequest, options?: any) {
            return DCAApiFp(configuration).dcaCreatePost(request, options)(fetch, basePath);
        },
        /**
         * Estimate Dca
         * @summary Estimate Dca
         * @param {DcascCreateDCARequest} request Create DCA Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcaEstimatePost(request: DcascCreateDCARequest, options?: any) {
            return DCAApiFp(configuration).dcaEstimatePost(request, options)(fetch, basePath);
        },
    };
};

/**
 * DCAApi - object-oriented interface
 * @export
 * @class DCAApi
 * @extends {BaseAPI}
 */
export class DCAApi extends BaseAPI {
    /**
     * Get Dcas
     * @summary Get Dcas
     * @param {string} address Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DCAApi
     */
    public dcaAddressGet(address: string, options?: any) {
        return DCAApiFp(this.configuration).dcaAddressGet(address, options)(this.fetch, this.basePath);
    }

    /**
     * Cancel Dca
     * @summary Cancel Dca
     * @param {DcascCancelDCARequest} request Cancel DCA Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DCAApi
     */
    public dcaCancelPost(request: DcascCancelDCARequest, options?: any) {
        return DCAApiFp(this.configuration).dcaCancelPost(request, options)(this.fetch, this.basePath);
    }

    /**
     * Create Dca
     * @summary Create Dca
     * @param {DcascCreateDCARequest} request Create DCA Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DCAApi
     */
    public dcaCreatePost(request: DcascCreateDCARequest, options?: any) {
        return DCAApiFp(this.configuration).dcaCreatePost(request, options)(this.fetch, this.basePath);
    }

    /**
     * Estimate Dca
     * @summary Estimate Dca
     * @param {DcascCreateDCARequest} request Create DCA Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DCAApi
     */
    public dcaEstimatePost(request: DcascCreateDCARequest, options?: any) {
        return DCAApiFp(this.configuration).dcaEstimatePost(request, options)(this.fetch, this.basePath);
    }

}

/**
 * MarkersApi - fetch parameter creator
 * @export
 */
export const MarkersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Call after succesful tx submission to mark the DCA as active or to activate the limit marker on a given TX
         * @summary Mark
         * @param {MarkersMarkerBody} request Marker Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markingSubmitPost(request: MarkersMarkerBody, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling markingSubmitPost.');
            }
            const localVarPath = `/marking/submit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
if (configuration && configuration.partnerToken) {
    localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
}

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MarkersMarkerBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarkersApi - functional programming interface
 * @export
 */
export const MarkersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Call after succesful tx submission to mark the DCA as active or to activate the limit marker on a given TX
         * @summary Mark
         * @param {MarkersMarkerBody} request Marker Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markingSubmitPost(request: MarkersMarkerBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = MarkersApiFetchParamCreator(configuration).markingSubmitPost(request, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MarkersApi - factory interface
 * @export
 */
export const MarkersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Call after succesful tx submission to mark the DCA as active or to activate the limit marker on a given TX
         * @summary Mark
         * @param {MarkersMarkerBody} request Marker Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markingSubmitPost(request: MarkersMarkerBody, options?: any) {
            return MarkersApiFp(configuration).markingSubmitPost(request, options)(fetch, basePath);
        },
    };
};

/**
 * MarkersApi - object-oriented interface
 * @export
 * @class MarkersApi
 * @extends {BaseAPI}
 */
export class MarkersApi extends BaseAPI {
    /**
     * Call after succesful tx submission to mark the DCA as active or to activate the limit marker on a given TX
     * @summary Mark
     * @param {MarkersMarkerBody} request Marker Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarkersApi
     */
    public markingSubmitPost(request: MarkersMarkerBody, options?: any) {
        return MarkersApiFp(this.configuration).markingSubmitPost(request, options)(this.fetch, this.basePath);
    }

}

/**
 * SwapApi - fetch parameter creator
 * @export
 */
export const SwapApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Average Price
         * @summary Get Average Price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapAveragePriceTokenInIdTokenOutIdGet(options: any = {}): FetchArgs {
            const localVarPath = `/swap/averagePrice/{tokenInId}/{tokenOutId}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel
         * @summary Cancel
         * @param {DtoCancelRequest} request Cancel Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapCancelPost(request: DtoCancelRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling swapCancelPost.');
            }
            const localVarPath = `/swap/cancel`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
if (configuration && configuration.partnerToken) {
    localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
}

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DtoCancelRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimate a trade
         * @summary Estimate Trade
         * @param {DtoEstimateRequest} request Estimate Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapEstimatePost(request: DtoEstimateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling swapEstimatePost.');
            }
            const localVarPath = `/swap/estimate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
if (configuration && configuration.partnerToken) {
    localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
}

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DtoEstimateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimate a limit order
         * @summary Estimate a limit order
         * @param {DtoLimitOrderRequest} request Limit Order Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapLimitEstimatePost(request: DtoLimitOrderRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling swapLimitEstimatePost.');
            }
            const localVarPath = `/swap/limitEstimate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
if (configuration && configuration.partnerToken) {
    localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
}

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DtoLimitOrderRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Limit Trade
         * @summary Limit Trade
         * @param {DtoLimitOrderRequest} request Limit Order Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapLimitPost(request: DtoLimitOrderRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling swapLimitPost.');
            }
            const localVarPath = `/swap/limit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
if (configuration && configuration.partnerToken) {
    localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
}

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DtoLimitOrderRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get User Orders
         * @summary Get User Orders
         * @param {string} userAddress User Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapOrdersUserAddressGet(userAddress: string, options: any = {}): FetchArgs {
            // verify required parameter 'userAddress' is not null or undefined
            if (userAddress === null || userAddress === undefined) {
                throw new RequiredError('userAddress','Required parameter userAddress was null or undefined when calling swapOrdersUserAddressGet.');
            }
            const localVarPath = `/swap/orders/{userAddress}`
                .replace(`{${"userAddress"}}`, encodeURIComponent(String(userAddress)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reverse Estimate a trade
         * @summary Reverse Estimate Trade
         * @param {DtoReverseEstimationRequest} request Reverse Estimate Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapReverseEstimatePost(request: DtoReverseEstimationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling swapReverseEstimatePost.');
            }
            const localVarPath = `/swap/reverseEstimate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
if (configuration && configuration.partnerToken) {
    localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
}

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DtoReverseEstimationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign a transaction
         * @summary Sign a transaction
         * @param {DtoSubmissionModel} request Submission Model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapSignPost(request: DtoSubmissionModel, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling swapSignPost.');
            }
            const localVarPath = `/swap/sign`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
if (configuration && configuration.partnerToken) {
    localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
}

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DtoSubmissionModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Build Swap
         * @summary Build Swap
         * @param {DtoSwapObject} request Swap Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapBuildPost(request: DtoSwapObject, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling swapBuildPost.');
            }
            const localVarPath = `/swap/build`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (configuration && configuration.partnerToken) {
                localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DtoSwapObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get wallet information
         * @summary Wallet
         * @param {DtoWallet} request Wallet Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapWalletPost(request: DtoWallet, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling swapWalletPost.');
            }
            const localVarPath = `/swap/wallet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
if (configuration && configuration.partnerToken) {
    localVarHeaderParameter[PartnerHeader] = configuration.partnerToken;
}

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DtoWallet" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SwapApi - functional programming interface
 * @export
 */
export const SwapApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Average Price
         * @summary Get Average Price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapAveragePriceTokenInIdTokenOutIdGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: number; }> {
            const localVarFetchArgs = SwapApiFetchParamCreator(configuration).swapAveragePriceTokenInIdTokenOutIdGet(options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Cancel
         * @summary Cancel
         * @param {DtoCancelRequest} request Cancel Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapCancelPost(request: DtoCancelRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DtoCancelResponse> {
            const localVarFetchArgs = SwapApiFetchParamCreator(configuration).swapCancelPost(request, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Estimate a trade
         * @summary Estimate Trade
         * @param {DtoEstimateRequest} request Estimate Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapEstimatePost(request: DtoEstimateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DtoEstimateResponse> {
            const localVarFetchArgs = SwapApiFetchParamCreator(configuration).swapEstimatePost(request, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Estimate a limit order
         * @summary Estimate a limit order
         * @param {DtoLimitOrderRequest} request Limit Order Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapLimitEstimatePost(request: DtoLimitOrderRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DtoLimitOrderEstimate> {
            const localVarFetchArgs = SwapApiFetchParamCreator(configuration).swapLimitEstimatePost(request, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Limit Trade
         * @summary Limit Trade
         * @param {DtoLimitOrderRequest} request Limit Order Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapLimitPost(request: DtoLimitOrderRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DtoLimitOrderResponse> {
            const localVarFetchArgs = SwapApiFetchParamCreator(configuration).swapLimitPost(request, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get User Orders
         * @summary Get User Orders
         * @param {string} userAddress User Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapOrdersUserAddressGet(userAddress: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModelsApiOrder>> {
            const localVarFetchArgs = SwapApiFetchParamCreator(configuration).swapOrdersUserAddressGet(userAddress, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reverse Estimate a trade
         * @summary Reverse Estimate Trade
         * @param {DtoReverseEstimationRequest} request Reverse Estimate Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapReverseEstimatePost(request: DtoReverseEstimationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DtoReverseEstimateResponse> {
            const localVarFetchArgs = SwapApiFetchParamCreator(configuration).swapReverseEstimatePost(request, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sign a transaction
         * @summary Sign a transaction
         * @param {DtoSubmissionModel} request Submission Model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapSignPost(request: DtoSubmissionModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DtoSignatureResponse> {
            const localVarFetchArgs = SwapApiFetchParamCreator(configuration).swapSignPost(request, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        try {
                            return response.json();
                        } catch (e) {
                            console.log(e)
                            throw new DexHunterApiError(e)
                        }
                    } else {
                        if (response.headers.get('Content-Type') === 'application/json') {
                            return Promise.resolve(response.json()).then((data) => {
                                throw new DexHunterApiError(data)
                            })
                        }
                        else {
                            return Promise.resolve(response.text()).then((data) => {
                                throw new DexHunterApiError(data)
                            })
                        }
                    }
                });
            };
        },
        /**
         * Build Swap
         * @summary Build Swap
         * @param {DtoSwapObject} request Swap Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapBuildPost(request: DtoSwapObject, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DtoSwapResponse> {
            const localVarFetchArgs = SwapApiFetchParamCreator(configuration).swapBuildPost(request, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        try {
                            return response.json();
                        } catch (e) {
                            console.log(e)
                            throw new DexHunterApiError(e)
                        }
                    } else {
                        if (response.headers.get('Content-Type') === 'application/json') {
                            return Promise.resolve(response.json()).then((data) => {
                                throw new DexHunterApiError(data)
                            })
                        }
                        else {
                            return Promise.resolve(response.text()).then((data) => {
                                throw new DexHunterApiError(data)
                            })
                        }
                    }
                });
            };
        },
        /**
         * Get wallet information
         * @summary Wallet
         * @param {DtoWallet} request Wallet Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapWalletPost(request: DtoWallet, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DtoWalletInfoResponse> {
            const localVarFetchArgs = SwapApiFetchParamCreator(configuration).swapWalletPost(request, options);
            return (fetch: FetchAPI , basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

//make the type for return of SwapApiFactory
export type SwapApiFactoryType = {
    swapAveragePriceTokenInIdTokenOutIdGet(options?: any): Promise<{ [key: string]: number; }>;
    swapCancelPost(request: DtoCancelRequest, options?: any): Promise<DtoCancelResponse>;
    swapEstimatePost(request: DtoEstimateRequest, options?: any): Promise<DtoEstimateResponse>;
    swapLimitEstimatePost(request: DtoLimitOrderRequest, options?: any): Promise<DtoLimitOrderEstimate>;
    swapLimitPost(request: DtoLimitOrderRequest, options?: any): Promise<DtoLimitOrderResponse>;
    swapOrdersUserAddressGet(userAddress: string, options?: any): Promise<Array<ModelsApiOrder>>;
    swapReverseEstimatePost(request: DtoReverseEstimationRequest, options?: any): Promise<DtoReverseEstimateResponse>;
    swapSignPost(request: DtoSubmissionModel, options?: any): Promise<DtoSignatureResponse>;
    swapBuildPost(request: DtoSwapObject, options?: any): Promise<DtoSwapResponse>;
    swapWalletPost(request: DtoWallet, options?: any): Promise<DtoWalletInfoResponse>;
};

/**
 * SwapApi - factory interface
 * @export
 */
export const SwapApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string):SwapApiFactoryType {
    return {
        /**
         * Get Average Price
         * @summary Get Average Price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapAveragePriceTokenInIdTokenOutIdGet(options?: any) {
            return SwapApiFp(configuration).swapAveragePriceTokenInIdTokenOutIdGet(options)(fetch, basePath);
        },
        /**
         * Cancel
         * @summary Cancel
         * @param {DtoCancelRequest} request Cancel Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapCancelPost(request: DtoCancelRequest, options?: any) {
            return SwapApiFp(configuration).swapCancelPost(request, options)(fetch, basePath);
        },
        /**
         * Estimate a trade
         * @summary Estimate Trade
         * @param {DtoEstimateRequest} request Estimate Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapEstimatePost(request: DtoEstimateRequest, options?: any) {
            return SwapApiFp(configuration).swapEstimatePost(request, options)(fetch, basePath);
        },
        /**
         * Estimate a limit order
         * @summary Estimate a limit order
         * @param {DtoLimitOrderRequest} request Limit Order Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapLimitEstimatePost(request: DtoLimitOrderRequest, options?: any) {
            return SwapApiFp(configuration).swapLimitEstimatePost(request, options)(fetch, basePath);
        },
        /**
         * Limit Trade
         * @summary Limit Trade
         * @param {DtoLimitOrderRequest} request Limit Order Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapLimitPost(request: DtoLimitOrderRequest, options?: any) {
            return SwapApiFp(configuration).swapLimitPost(request, options)(fetch, basePath);
        },
        /**
         * Get User Orders
         * @summary Get User Orders
         * @param {string} userAddress User Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapOrdersUserAddressGet(userAddress: string, options?: any) {
            return SwapApiFp(configuration).swapOrdersUserAddressGet(userAddress, options)(fetch, basePath);
        },
        /**
         * Reverse Estimate a trade
         * @summary Reverse Estimate Trade
         * @param {DtoReverseEstimationRequest} request Reverse Estimate Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapReverseEstimatePost(request: DtoReverseEstimationRequest, options?: any) {
            return SwapApiFp(configuration).swapReverseEstimatePost(request, options)(fetch, basePath);
        },
        /**
         * Sign a transaction
         * @summary Sign a transaction
         * @param {DtoSubmissionModel} request Submission Model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapSignPost(request: DtoSubmissionModel, options?: any) {
            return SwapApiFp(configuration).swapSignPost(request, options)(fetch, basePath);
        },
        /**
         * Build Swap
         * @summary Build Swap
         * @param {DtoSwapObject} request Swap Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapBuildPost(request: DtoSwapObject, options?: any) {
            return SwapApiFp(configuration).swapBuildPost(request, options)(fetch, basePath);
        },
        /**
         * Get wallet information
         * @summary Wallet
         * @param {DtoWallet} request Wallet Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapWalletPost(request: DtoWallet, options?: any) {
            return SwapApiFp(configuration).swapWalletPost(request, options)(fetch, basePath);
        },
    };
};

/**
 * SwapApi - object-oriented interface
 * @export
 * @class SwapApi
 * @extends {BaseAPI}
 */
export class SwapApi extends BaseAPI {
    /**
     * Get Average Price
     * @summary Get Average Price
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public swapAveragePriceTokenInIdTokenOutIdGet(options?: any) {
        return SwapApiFp(this.configuration).swapAveragePriceTokenInIdTokenOutIdGet(options)(this.fetch, this.basePath);
    }

    /**
     * Cancel
     * @summary Cancel
     * @param {DtoCancelRequest} request Cancel Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public swapCancelPost(request: DtoCancelRequest, options?: any) {
        return SwapApiFp(this.configuration).swapCancelPost(request, options)(this.fetch, this.basePath);
    }

    /**
     * Estimate a trade
     * @summary Estimate Trade
     * @param {DtoEstimateRequest} request Estimate Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public swapEstimatePost(request: DtoEstimateRequest, options?: any) {
        return SwapApiFp(this.configuration).swapEstimatePost(request, options)(this.fetch, this.basePath);
    }

    /**
     * Estimate a limit order
     * @summary Estimate a limit order
     * @param {DtoLimitOrderRequest} request Limit Order Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public swapLimitEstimatePost(request: DtoLimitOrderRequest, options?: any) {
        return SwapApiFp(this.configuration).swapLimitEstimatePost(request, options)(this.fetch, this.basePath);
    }

    /**
     * Limit Trade
     * @summary Limit Trade
     * @param {DtoLimitOrderRequest} request Limit Order Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public swapLimitPost(request: DtoLimitOrderRequest, options?: any) {
        return SwapApiFp(this.configuration).swapLimitPost(request, options)(this.fetch, this.basePath);
    }

    /**
     * Get User Orders
     * @summary Get User Orders
     * @param {string} userAddress User Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public swapOrdersUserAddressGet(userAddress: string, options?: any) {
        return SwapApiFp(this.configuration).swapOrdersUserAddressGet(userAddress, options)(this.fetch, this.basePath);
    }

    /**
     * Reverse Estimate a trade
     * @summary Reverse Estimate Trade
     * @param {DtoReverseEstimationRequest} request Reverse Estimate Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public swapReverseEstimatePost(request: DtoReverseEstimationRequest, options?: any) {
        return SwapApiFp(this.configuration).swapReverseEstimatePost(request, options)(this.fetch, this.basePath);
    }

    /**
     * Sign a transaction
     * @summary Sign a transaction
     * @param {DtoSubmissionModel} request Submission Model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public swapSignPost(request: DtoSubmissionModel, options?: any) {
        return SwapApiFp(this.configuration).swapSignPost(request, options)(this.fetch, this.basePath);
    }

    /**
     * Build Swap
     * @summary Build Swap
     * @param {DtoSwapObject} request Swap Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public swapBuildPost(request: DtoSwapObject, options?: any) {
        return SwapApiFp(this.configuration).swapBuildPost(request, options)(this.fetch, this.basePath);
    }

    /**
     * Get wallet information
     * @summary Wallet
     * @param {DtoWallet} request Wallet Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwapApi
     */
    public swapWalletPost(request: DtoWallet, options?: any) {
        return SwapApiFp(this.configuration).swapWalletPost(request, options)(this.fetch, this.basePath);
    }

}

